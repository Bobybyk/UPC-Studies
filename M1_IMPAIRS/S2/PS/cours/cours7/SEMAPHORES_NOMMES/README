Makefile.mac       pour MacOS
Makefile.linux     pour Linux


lecteur_nomme et ecrivain_nomme : deux programmes qui communiquent
par la memoire partagée obtenue par la projection en mémoire d'un
shared memory object.

ecrivain_nomme  écrit des message dans la mémoire partagée,
lecteur-nomme lit les messages fournis par l'écrivain et les affiche
sur le terminal. 

L'accès à la mémoire est protégé par deux sémaphores nommé : sem_rec
et sem_send.

C'est lecteur_nomme qui initialise (est construit) les deux semaphores donc
il faut d'abord lancer ce programme. Un seul lecteur_nomme nomme doit être
lancé.

Par contre on peut lancer plusieurs ecrivain_nomme.

lancement de lecteur:

./lecteur_nomme memory_objet sem_send sem_rec

où memory_object le nom de shared memory object
sem_send et sem_rec les noms de deux sémaphores.

lancement d'écrivain:

./ecrivain_nomme memory_objet sem_send sem_rec  message

où message est le message que l'écrivain va envoyer.
Ecrivain envoie 10 messages et s'arrête par contre le lecteur tourne
dans une boucle infinie.




Pour lancer trois trois ecrivains:

./ecrivain_nomme a b c "mess un" & ./ecrivain_nomme a b c "mess deux" &./ecrivain_nomme a b c "mess trois" &

où les trois premiers paramètres sont les mêmes que pour le lecteur et le dernier paramètre est le message à envoyer.



Initialement sem_send est initialisé 0,
et sem_rec 1.

l'algorithme de l'écrivain :         l'algorithme de lecteur :

sem_wait( sem_rec )                       sem_wait( sem_send )

écrire                                    lire

sem_post( sem_send )                      sem_post( sem_rec )

donc initialement le lecteur est bloqué et un écrivain (et un seul) passe
l'opération sem_wait( sem_rec ) et écrit dans la mémoire partagé. Après avoir
écrit l'écrivain libère un lecteur grâce à sem_post(sem_send).

Nous pouvons voire que l'écrivain et le lecteur accèdent à la mémoire partagée
à tour de rôle.
